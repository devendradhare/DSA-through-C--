//                      DSA through C++
//            Assignment-4: Singly Linked List
class node
{
public:
    int data;
    node *next;
    node()
    {
        data = 0;
        next = NULL;
    }
};

class SLL
{
private:
    node *start;     // 1.  Define a class SLL to implement singly linked list data structure with member
    node *last_node; //     variable start pointer of type node.
    int last_index = -1;

public:
    SLL() { start = NULL; }        // 2.  In question 1, define a constructor to initialise start pointer with NULL.
    void insert_at_beginning(int); // 3.  In question 1, define a method to insert a data into the list at the beginning.
    void insert_at_end(int);       // 4.  In question 1, define a method to insert a data into the list at the end
    int search(int);               // 5.  In question 1, define a method to search a node with the give item.
    void insert(int, int);         // 6.  In question 1, define a method to insert a data into the list after the specified node of the list.
    void delete_first();           // 7.  In question 1, define a method to delete first node from the list.
    void delete_last();            // 8.  In question 1, define a rnethod to delete last node Of the list.
    void delete_index(int);        // 9.  In question 1, define a method to delete a specific node.
    ~SLL();                        // 10. In question 1, define a destructor to deallocates memory for all the nodes in the linked list.
    void show_list();
};
void SLL::insert_at_beginning(int data)
{
    node *temp;
    temp = new node;
    temp->data = data;
    temp->next = start;
    start = temp;

    last_index++;
}

void SLL::insert_at_end(int data)
{
    if (start == NULL)
        insert_at_beginning(data);
    node *n = start;
    node *temp;
    for (int i = 0; i < last_index - 1; i++)
    {
        n = n->next;
    }
    temp = new node;
    temp->data = data;
    n->next = temp;

    last_index++;
}

void SLL::show_list()
{
    node *n = start;
    std::cout << "\n";
    for (int i = 0; i <= last_index; i++)
    {
        std::cout << " " << n->data << ",";
        n = n->next;
    }
}

int SLL::search(int item)
{
    node *n = start;
    for (int i = 0; i <= last_index; i++)
    {
        if (n->data == item)
            return i;
        n = n->next;
    }
    return -1;
}

void SLL::insert(int index, int data)
{
    if (index < 0 || index > last_index)
    {
        std::cout << "<insert : Invalid index>";
        return;
    }
    if (index == 0)
    {
        insert_at_beginning(data);
        return;
    }
    node *temp = new node;
    temp->data = data;

    node *n = start;
    for (int i = 0; i < index; i++)
    {
        n = n->next;
    }
    node *t = n->next;
    n->next = temp;
    temp->next = t;
    last_index++;
}

void SLL::delete_first()
{
    node *temp;
    temp = start;
    start = start->next;
    delete temp;
    last_index--;
}

void SLL::delete_last()
{
    if (start = NULL)
    {
        std::cout << "< delete_last : Array is Empty >";
        return;
    }
    if (start->next == NULL)
    {
        delete start;
        start = NULL;
        return;
    }

    node *n = start;
    while (n->next->next != NULL)
    {
        n = n->next;
    }
    delete n->next;
    n->next = NULL;
    last_index--;
}

void SLL::delete_index(int index)
{
    if (index < 0 || index > last_index)
    {
        std::cout << "<delete : Invalid index>";
        return;
    }
    if (index == 0)
        delete_first();
    node *n = start;
    for (int i = 0; i < index - 1; i++)
    {
        n = n->next;
    }
    node *temp = n->next;
    n->next = n->next->next;
    last_index--;
}

SLL::~SLL()
{
    for (int i = 0; i <= last_index; i++)
    {
        std::cout << " " << i;
        delete_first();
    }
}